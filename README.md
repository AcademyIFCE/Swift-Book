# Swift Book

Esse projeto tem como objetivo traduzir e disponibilizar gratuitamente em portugu√™s o livro *The Swift Programming Language (swift 5.1)*. 

## O que j√° pode ser traduzido

O livro em ingl√™s est√° lentamente sendo migrado para o formato de *Markdown*  antes de ser traduzido. A seguintes *Sess√µes* j√° est√£o em formato *Markdown* e j√° podem ser traduzidas atrav√©s de Pull Requests:

- [x] About Swift
- [x] Version Compatibility
- [x] A Swift Tour
  - [x] Intro
  - [x] Simple Values
  - [x] Control Flow
  - [x] Functions and Closures
  - [x] Objects and Classes
  - [x] Enumerations and Structures
  - [x] Protocols and Extensions
  - [x] Error Handling
  - [x] Generics
- [ ] The Basics
  - [ ] Intro
  - [ ] Constants and Variables
  - [ ] Floating-Point Numbers
  - [ ] Type Safety and Type Inference
  - [ ] Numeric Type Conversion
  - [ ] Assertions and Preconditions
- [x] Basic Operators
  - [x] Intro
  - [x] Terminology
  - [x] Assignment Operator
  - [x] Arithmetic Operators
  - [x] Compound Assignment Operators
  - [x] Comparison Operators
  - [x] Ternary Conditional Operator
  - [x] Nil-Coalescing Operator
  - [x] Range Operators
  - [x] Logical Operators
- [ ] Strings And Characters
  - [ ] Intro
  - [ ] String Literals
  - [ ] Initializing an Empty String
  - [ ] String Mutability
  - [ ] Strings Are Value Types
  - [ ] Working with Characters
  - [ ] Concatenating Strings and Characters
  - [ ] String Interpolation
  - [ ] Unicode
  - [ ] Counting Characters
  - [ ] Accessing and Modifying a String
  - [ ] Substrings
  - [ ] Unicode
  - [ ] Comparing Strings
  - [ ] Unicode Representations of Strings
- [ ] Collection Types
  - [ ] Intro
  - [ ] Mutability of Collections
  - [ ] Arrays
  - [ ] Sets
  - [ ] Performing Set Operations
  - [ ] Dictionaries
- [ ] Control Flow
  - [ ] Intro
  - [ ] For-In Loops
  - [ ] While Loops
  - [ ] Conditional Statements
  - [ ] Control Transfer Statements
  - [ ] Early Exit
  - [ ] Checking API Availability
- [ ] Closures
  - [X] Intro
  - [X] Closure Expressions
  - [ ] Trailing Closures
  - [ ] Capturing Values
  - [ ] Closures Are Reference Types
  - [ ] Escaping Closures
  - [ ] Autoclosures
- [ ] Enumerations
  - [ ] Intro
  - [ ] Enumeration Syntax
  - [ ] Matching Enumeration Values with a Switch Statement
  - [ ] Iterating over Enumeration Cases
  - [ ] Associated Values
  - [ ] Raw Values
  - [ ] Recursive Enumerations
- [ ] Structures and Classes
  - [ ] Intro
  - [ ] Comparing Structures and Classes
  - [ ] Structures and Enumerations Are Value Types
  - [ ] Classes Are Reference Types
- [ ] Methods
  - [ ] Intro
  - [ ] Instance Methods
  - [ ] Type Methods
- [ ] Optional Chaining
  - [ ] Intro
  - [ ] Optional Chaining as an Alternative to Forced Unwrapping
  - [ ] Defining Model Classes for Optional Chaining
  - [ ] Accessing Properties Through Optional Chaining
  - [ ] Calling Methods Through Optional Chaining
  - [ ] Accessing Subscripts Through Optional Chaining
  - [ ] Linking Multiple Levels of Chaining
  - [ ] Chaining on Methods with Optional Return Values
- [ ] Nested Types
  - [ ] Intro
  - [ ] Nested Types in Action
  - [ ] Referring to Nested Types
- [ ] Generics
  - [x] Intro
  - [x] The Problem That Generics Solve
  - [x] Generic Functions
  - [ ] Type Parameters
  - [ ] Naming Type Parameters
  - [ ] Generic Types
  - [ ] Extending a Generic Type
  - [ ] Type Constraints
  - [ ] Associated Types
  - [ ] Generic Where Clauses
  - [ ] Extensions with a Generic Where Clause
  - [ ] Associated Types with a Generic Where Clause 
  - [ ] Generic Subscripts
- [ ] Access Control
  - [ ] Intro
  - [ ] Modules and Source Files
  - [ ] Access Levels
  - [ ] Access Control Syntax
  - [ ] Custom Types
  - [ ] Subclassing
  - [ ] Constants, Variables, Properties, and Subscripts 
  - [ ] Initializers
  - [ ] Protocols
  - [ ] Extensions
  - [ ] Generics
  - [ ] Type Aliases
- [ ] Adavanced Operators
  - [ ] Intro
  - [ ] Bitwise Operators
  - [ ] Overflow Operators
  - [ ] Precedence and Associativity
  - [ ] Operator Methods
  - [ ] Custom Operators

Cada item dessa lista ter√° uma Issue. **Antes de pegar um desses items para traduzir, verifique a Issue e descubra se algu√©m j√° n√£o est√° traduzindo**. Quando algu√©m pegar uma dessas `sessao/topico` para traduzir, ter√° o nome atribu√≠do a Issue.

## Conven√ß√µes

Para facilitar o processo de revis√£o e diminuir as inconsist√™ncias entre tradu√ß√µes, quem contribuir dever√° seguir algumas conven√ß√µes:

* N√£o traduzir palavras reservadas.
* Na d√∫vida entre traduzir ou n√£o determinado termo, deixar o termo em ingl√™s.
* Criar Branches no padr√£o `sessao/topico`  e traduzir por *Sessao* e *T√≥pico* (textos mais internos dentro da *Sess√£o*).
* *Pull Requests* devem ser feitos para `master`, marcando a Issue que resolvem.

## Cria√ß√£o de Branches

A tradu√ß√£o dever√° ser feita atrav√©s de Forks, com branches nomeadas por sess√£o e t√≥pico, com letras min√∫sculas, seguindo o seguinte padr√£o:

`nome-da-sessao/nome-do-topico`

Exemplo:
`a-swift-tour/control-flow`

Caso n√£o existam t√≥picos para determinada sess√£o, a branch deve ter somente o nome da sess√£o:
`nome-da-sessao`

## Pull Requests

Os Pull Requests devem ser feitos diretamente para a branch `master`, e marcar a Issue que est√° resolvendo. A revis√£o ser√° feita avaliando a tradu√ß√£o em si, a coer√™ncia do texto da tradu√ß√£o, e a coer√™ncia com as tradu√ß√µes anteriores.

## Come√ße Agora! üéâ  

Existe pouco ou nenhum material gratuito em portugu√™s de Swift / Desenvolvimento iOS b√°sico. Contribuindo com a tradu√ß√£o desse livro, voc√™ pode estar ajudando algu√©m que n√£o tem $$$ para comprar material a estudar. Al√©m disso, voc√™ mesmo estar√° estudando, revisando, e aprendendo recursos da linguagem que voc√™ talvez n√£o conhe√ßa.

Com esfor√ßo coletivo, conseguiremos finalizar a tradu√ß√£o e facilitar o aprendizado de desenvolvimento iOS para quem n√£o sabe ingl√™s. 
